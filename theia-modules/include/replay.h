#ifndef __REPLAY_H__
#define __REPLAY_H__

//used to prevent accidental inclusion of the old replay.h
#define __THEIA_MODULES__

//begin kernel includes
#include <linux/mutex.h>
#include <linux/types.h>
#include <linux/signal.h>
#include <linux/wait.h>
#include <linux/file.h>
#include <linux/fdtable.h>
#include <linux/syscalls.h>
#include <linux/net.h>
//end kernel includes

//begin Theia includes

#include <replay_configs.h>
#include <theia_syscalls.h>

//replay_graph
#include <ds_list.h>
#include <replay_maps.h>
#include <replay_graph/replayfs_filemap.h>
#include <replay_graph/replayfs_perftimer.h>

//Log compression
#include <xcomp.h>
#include <c_cache.h>
#include <c_status.h>

//end Theia includes

#define RECORD_FILE_SLOTS 1024
#define MAX_LOGDIR_STRLEN 256
#define MAX_LIBPATH_STRLEN PAGE_SIZE
#define MAX_WHITELIST_STRLEN 512
#define MAX_DIRENT_STRLEN 256
#define REPLAY_MAX_RANDOM_VALUES 100

struct record_group
{
    // Unique identifier for all time for this recording
    __u64 rg_id;

  struct mutex rg_mutex;      // Protect all structures for group
  atomic_t rg_refcnt;         // Refs to this structure

  char rg_logdir[MAX_LOGDIR_STRLEN + 1]; // contains the directory to which we will write the log

  struct page *rg_shared_page;          // Used for shared clock below
  atomic_t *rg_pkrecord_clock;          // Where clock is mapped into kernel address space for this record/replay
  char rg_shmpath[MAX_LOGDIR_STRLEN + 1]; // contains the path of the shared-memory file that we will used for user-level mapping of clock

  char rg_linker[MAX_LOGDIR_STRLEN + 1]; // contains the name of a special linker to use - for user level pthread library


  atomic_t rg_record_threads; // Number of active record threads
  int rg_save_mmap_flag;    // If on, records list of mmap regions during record
  ds_list_t *rg_reserved_mem_list; // List of addresses that are mmaped, kept on the fly as they occur
  u_long rg_prev_brk;   // the previous maximum brk, for recording memory maps
  char rg_mismatch_flag;      // Set when an error has occurred and we want to abandon ship
  char *rg_libpath;           // For glibc hack
};

// This structure has task-specific replay data
struct replay_group
{
  struct record_group *rg_rec_group; // Pointer to record group
  ds_list_t *rg_replay_threads; // List of replay threads for this group
  atomic_t rg_refcnt;         // Refs to this structure
  ds_list_t *rg_reserved_mem_list; // List of addresses we should preallocate to keep pin from using them
  u_long rg_max_brk;          // Maximum value of brk address
  ds_list_t *rg_used_address_list; // List of addresses that will be used by the application (and hence, not by pin)
  int rg_follow_splits;       // Ture if we should replay any split-off replay groups
  char cache_dir[CACHE_FILENAME_SIZE+1];
};

struct argsalloc_node
{
  struct list_head list;
  void            *head;
  void            *pos;
  size_t           size;
};

#define SR_HAS_RETPARAMS        0x1
#define SR_HAS_SIGNAL           0x2
#define SR_HAS_START_CLOCK_SKIP 0x4
#define SR_HAS_STOP_CLOCK_SKIP  0x8
#define SR_HAS_NONZERO_RETVAL   0x10
#define SR_HAS_SPECIAL_FIRST  0x20
#define SR_HAS_SPECIAL_SECOND 0x40
#define SR_HAS_RECORD_UUID 0x80

// This structure records the result of a system call
struct syscall_result
{
  short     sysnum;   // system call number executed
  u_char                  flags;          // See defs above
};

// This structure records/replays random values generated by the kernel
// Only used for the execve system call right now - is it needed elsewhere?
struct rvalues
{
  int    cnt;
  u_long val[REPLAY_MAX_RANDOM_VALUES];
};

// This structure records/replays other values passed to an executable during exec
struct exec_values
{
  int uid;
  int euid;
  int gid;
  int egid;
  int secureexec;
};

// This saves record context from when signal was delivered
struct repsignal_context
{
  int ignore_flag;
  struct repsignal_context *next;
};

/* replay signal data */
struct repsignal
{
  int signr;
  siginfo_t info;
  struct k_sigaction ka;
  sigset_t blocked;
  sigset_t real_blocked;
  struct repsignal *next;
};

struct pipe_fds
{
  int *fds;
  int length;
  int size;
  struct mutex lock;
};

struct clog_struct
{
  //for log compression
  int done;
  int args_size;
  struct syscallCache syscall_cache;

  struct x_struct x;
  long clock_predict;
  struct pipe_fds pfds;

  struct status_info syscall_status;
};

struct record_cache_data
{
  char is_cache_file; // True if this is a cache file descriptor
  struct mutex mutex;  // Only one thread at a time gets to access the descriptor
};

struct record_cache_chunk
{
  int                        count; // Number of files in this chunk
  struct record_cache_data  *data;  // Dynamically allocated array of data
  struct record_cache_chunk *next;  // Next chunk
};

struct record_cache_files
{
  atomic_t                   refcnt; // Refs to this structure
  struct rw_semaphore        sem; // Protects this structure
  int                        count; // Maximum number of files in this struct
  struct record_cache_chunk *list;  // Array of flags per file descriptor
};

struct inode_data
{
  atomic_t refcnt;
  struct mutex replay_inode_lock;
  int read_opens;
  int write_opens;
  u64 key;
  loff_t version;
};

struct filemap_data
{
#ifdef TRACE_READ_WRITE
  struct replayfs_filemap map;
#endif
  struct inode_data *idata;
  loff_t last_version;
};

struct replay_cache_files
{
  atomic_t refcnt; // Refs to this structure
  int      count; // Maximum number of files in this struct
  int     *data;  // Array of cache fds per file descriptor
};

//This has record thread specific data
struct record_thread
{
  struct record_group *rp_group; // Points to record group
  struct record_thread *rp_next_thread; // Circular record thread list

  atomic_t rp_refcnt;            // Reference count for this object
  pid_t rp_record_pid;           // Pid of recording task (0 if not set)
  short rp_clone_status;         // Prevent rec task from exiting
  // before rep task is created
  // (0:init,1:cloning,2:completed)
  long rp_sysrc;                 // Return code for replay_prefork

  /* Recording log */
  struct syscall_result *rp_log;  // Logs system calls per thread
  u_long rp_in_ptr;               // Next record to insert
  u64 rp_count;                   // Number of syscalls run by this thread

  loff_t rp_read_log_pos;   // The current position in the log file that is being read
  struct list_head rp_argsalloc_list; // kernel linked list head pointing to linked list of argsalloc_nodes

  u_long rp_user_log_addr;        // Where the user log info is stored
  int __user *rp_ignore_flag_addr;      // Where the ignore flag is stored

  struct rvalues random_values;   // Tracks kernel randomness during syscalls (currently execve only)
  struct exec_values exec_values; // Track other exec-specifc values

  atomic_t *rp_precord_clock;     // Points to the recording clock in use
  u_long  rp_expected_clock;      // Used for delta clock

  char rp_ulog_opened;    // Flag that says whether or not the user log has been opened
  char rp_klog_opened;    // Flag that says whether or not the kernel log has been opened
  char ahg_rp_log_opened;   // Flag that says whether or not the ahg log has been opened
  loff_t rp_read_ulog_pos;  // The current position in the ulog file that is being read
  struct repsignal_context *rp_repsignal_context_stack;  // Saves replay context on signal delivery
  u_long rp_record_hook;          // Used for dumbass linking in glibc
  struct repsignal *rp_signals;   // Stores delayed signals
  struct repsignal *rp_last_signal; // Points to last signal recorded for this process

  loff_t prev_file_version[RECORD_FILE_SLOTS];

#ifdef TRACE_READ_WRITE
  struct replayfs_filemap recorded_filemap[RECORD_FILE_SLOTS];
  char recorded_filemap_valid[RECORD_FILE_SLOTS];
#endif

#ifdef CACHE_READS
  struct record_cache_files *rp_cache_files; // Info about open cache files
#endif
#ifdef LOG_COMPRESS
  struct clog_struct rp_clog;   // additional parameters used by compressed log
#endif
};

// This has replay thread specific data
struct replay_thread
{
  struct replay_group *rp_group; // Points to replay group
  struct replay_thread *rp_next_thread; // Circular replay thread list
  struct record_thread *rp_record_thread; // Points to record thread

  atomic_t rp_refcnt;            // Reference count for this object
  pid_t rp_replay_pid;           // Pid of replaying task (0 if not set)
  u_long rp_out_ptr;             // Next record to read
  short rp_replay_exit;          // Set after a rollback
  u_char rp_signals;             // Set if sig should be delivered
  u_long app_syscall_addr;       // Address in user-land that is set when the syscall should be replayed

  int rp_status;                  // One of the replay statuses above
  u_long rp_wait_clock;           // Valid if waiting for kernel or user-level clock according to rp_status
  u_long rp_stop_clock_skip;      // Temporary storage while processing syscall
  wait_queue_head_t rp_waitq;     // Waiting on this queue if in one of the waiting states

  long rp_saved_rc;               // Stores syscall result when blocking in syscall conflicts with a pin lock
  char *rp_saved_retparams;       // Stores syscall results when blocking in syscall conflicts with a pin lock
  struct syscall_result *rp_saved_psr; // Stores syscall info when blocking in syscall conflicts with a pin lock
  struct rvalues random_values;   // Tracks kernel randomness during syscalls (currently execve only)
  struct exec_values exec_values; // Track other exec-specifc values

  u_long *rp_preplay_clock;       // Points to the replay clock in use
  u_long  rp_expected_clock;      // Used for delta clock
  struct list_head rp_sysv_list;  // List of mappings from replay SYSV IDs to reocrd SYSV IDs
  struct list_head rp_sysv_shms;  // List of SYSV shared memory segments for this process/thread
  u_long rp_replay_hook;          // Used for dumbass linking in glibc

  const char *rp_exec_filename;   // Used during execve to pass same arguments as recording (despite use of cache file)
  int rp_pin_restart_syscall; // Used to see if we should restart a syscall because of Pin
  u_long rp_start_clock_save; // Save the value of the start clock to resume after Pin returns back
  u_long rp_stop_clock_save;  // Save the value of the stop clock to resume after Pin returns back
  u_long argv;      // Save the location of the program args
  int argc;     // Save the number of program args
  u_long envp;      // Save the location of the env. vars
  int envc;     // Save the number of environment vars
  int is_pin_vfork;   // Set 1 when Pin calls clone instead of vfork
#ifdef CACHE_READS
  struct replay_cache_files *rp_cache_files; // Info about open cache files
#endif
};

struct open_retvals
{
  dev_t           dev;
  u_long          ino;
  struct timespec mtime;
};

extern unsigned long pin_debug_clock;

#define TPRINT pr_debug
#define DPRINT pr_debug
#define MPRINT pr_debug

/* Performance evaluation timers... micro monitoring */
extern struct perftimer *write_in_timer;
extern struct perftimer *write_sys_timer;
extern struct perftimer *write_filemap_timer;
extern struct perftimer *write_traceread_timer;

extern struct perftimer *read_in_timer;
extern struct perftimer *read_cache_timer;
extern struct perftimer *read_sys_timer;
extern struct perftimer *read_traceread_timer;
extern struct perftimer *read_filemap_timer;

extern struct perftimer *open_timer;
extern struct perftimer *open_sys_timer;
extern struct perftimer *open_intercept_timer;
extern struct perftimer *open_cache_timer;

extern struct perftimer *close_timer;
extern struct perftimer *close_sys_timer;
extern struct perftimer *close_intercept_timer;

/* Optional stats interface */
#ifdef REPLAY_STATS
struct replay_stats {
    atomic_t started;
    atomic_t finished;
    atomic_t mismatched;
};
extern struct replay_stats rstats;
long get_replay_stats(struct replay_stats __user*);
#endif

/* For synchronization points in kernel outside of replay.c */
#define TID_WAKE_CALL 500

//trailing includes that need what is defined in this header above
#include <util.h>

#endif
